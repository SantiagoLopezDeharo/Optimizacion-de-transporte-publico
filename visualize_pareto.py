#!/usr/bin/env python3
"""Pareto visualization utilities.

Loads the latest mono-objective CSV (generated by the weighted/aggregated run)
and the latest multi-objective CSV (generated by the 3-objective run), then
plots both Pareto approximations together.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import glob
import os
import io
from typing import Dict, List, Optional, Tuple

# Configurar estilo
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 8)

def _load_latest_csv(pattern: str, *, exclude_substrings: Optional[List[str]] = None):
    """Load the newest CSV matching a glob pattern (optionally excluding names)."""
    files = glob.glob(pattern)
    if exclude_substrings:
        files = [f for f in files if all(s not in os.path.basename(f) for s in exclude_substrings)]

    if not files:
        raise FileNotFoundError(f"No CSV files found for pattern: {pattern}")

    latest_file = max(files, key=os.path.getctime)
    print(f"Loading data from: {latest_file}")

    # Some historical files were generated with literal "\\n" instead of real newlines.
    # If so, fix in-memory so pandas can parse the CSV correctly.
    with open(latest_file, 'r', encoding='utf-8-sig', newline='') as f:
        raw = f.read()

    if '\n' not in raw and '\\n' in raw:
        raw = raw.replace('\\n', '\n')
        df = pd.read_csv(io.StringIO(raw))
    else:
        df = pd.read_csv(io.StringIO(raw))

    # Normalize column names
    df.columns = [c.strip() for c in df.columns]

    if len(df) == 0:
        raise ValueError(f"The file {latest_file} contains 0 rows")

    return df, latest_file


def load_latest_mono_results():
    """Load the latest mono-objective (weighted aggregation) Pareto approximation."""
    df, path = _load_latest_csv('paradas/pareto_results_*.csv', exclude_substrings=['_multi_'])

    required_cols = {'w_coverage', 'w_stops', 'w_cost', 'coverage', 'num_stops', 'cost', 'fitness'}
    missing = required_cols - set(df.columns)
    if missing:
        raise ValueError(
            f"Mono-objective file {path} is missing columns: {sorted(missing)}. "
            f"Detected columns: {list(df.columns)}"
        )

    return df, path


def load_latest_multi_results():
    """Load the latest multi-objective (3 objectives, no weights) Pareto approximation."""
    df, path = _load_latest_csv('paradas/pareto_results_multi_*.csv')

    required_cols = {'coverage', 'num_stops', 'cost'}
    missing = required_cols - set(df.columns)
    if missing:
        raise ValueError(
            f"Multi-objective file {path} is missing columns: {sorted(missing)}. "
            f"Detected columns: {list(df.columns)}"
        )

    return df, path

def plot_pareto_3d(df, output_file='pareto_3d.png'):
    """Genera gráfico 3D del frente de Pareto"""
    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')
    
    # Crear gradiente de color basado en fitness
    colors = df['fitness']
    scatter = ax.scatter(df['coverage'], df['num_stops'], df['cost'], 
                        c=colors, cmap='viridis', s=100, alpha=0.6, edgecolors='black')
    
    ax.set_xlabel('Coverage', fontsize=12, fontweight='bold')
    ax.set_ylabel('Number of Stops', fontsize=12, fontweight='bold')
    ax.set_zlabel('Cost', fontsize=12, fontweight='bold')
    ax.set_title('Pareto Front - 3D Objective Space (Mono-objective)', fontsize=14, fontweight='bold')
    
    # Agregar barra de color
    cbar = plt.colorbar(scatter, ax=ax, pad=0.1, shrink=0.8)
    cbar.set_label('Aggregated Fitness', rotation=270, labelpad=20, fontweight='bold')
    
    plt.tight_layout()
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"3D plot saved to: {output_file}")
    plt.close()

def plot_pareto_2d_projections(df, output_file='pareto_2d_projections.png'):
    """Genera proyecciones 2D del frente de Pareto"""
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    
    # Coverage vs Stops
    ax1 = axes[0, 0]
    scatter1 = ax1.scatter(df['coverage'], df['num_stops'], 
                          c=df['fitness'], cmap='viridis', s=100, alpha=0.6, edgecolors='black')
    ax1.set_xlabel('Coverage', fontweight='bold')
    ax1.set_ylabel('Number of Stops', fontweight='bold')
    ax1.set_title('Coverage vs Number of Stops (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter1, ax=ax1, label='Fitness')
    
    # Coverage vs Cost
    ax2 = axes[0, 1]
    scatter2 = ax2.scatter(df['coverage'], df['cost'], 
                          c=df['fitness'], cmap='viridis', s=100, alpha=0.6, edgecolors='black')
    ax2.set_xlabel('Coverage', fontweight='bold')
    ax2.set_ylabel('Cost', fontweight='bold')
    ax2.set_title('Coverage vs Cost (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter2, ax=ax2, label='Fitness')
    
    # Stops vs Cost
    ax3 = axes[1, 0]
    scatter3 = ax3.scatter(df['num_stops'], df['cost'], 
                          c=df['fitness'], cmap='viridis', s=100, alpha=0.6, edgecolors='black')
    ax3.set_xlabel('Number of Stops', fontweight='bold')
    ax3.set_ylabel('Cost', fontweight='bold')
    ax3.set_title('Number of Stops vs Cost (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter3, ax=ax3, label='Fitness')
    
    # Fitness vs Weight Coverage
    ax4 = axes[1, 1]
    scatter4 = ax4.scatter(df['w_coverage'], df['fitness'], 
                          c=df['fitness'], cmap='viridis', s=100, alpha=0.6, edgecolors='black')
    ax4.set_xlabel('Coverage Weight (w1)', fontweight='bold')
    ax4.set_ylabel('Fitness', fontweight='bold')
    ax4.set_title('Fitness vs Coverage Weight (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter4, ax=ax4, label='Fitness')
    
    plt.tight_layout()
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"2D projections saved to: {output_file}")
    plt.close()

def plot_weight_influence(df, output_file='weight_influence.png'):
    """Analiza la influencia de los pesos en los objetivos"""
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    
    # Weight Coverage vs Coverage
    ax1 = axes[0, 0]
    scatter1 = ax1.scatter(df['w_coverage'], df['coverage'], 
                          c=df['fitness'], cmap='coolwarm', s=100, alpha=0.6, edgecolors='black')
    ax1.set_xlabel('Coverage Weight (w1)', fontweight='bold')
    ax1.set_ylabel('Coverage Achieved', fontweight='bold')
    ax1.set_title('Influence of w1 on Coverage (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter1, ax=ax1, label='Fitness')
    
    # Weight Stops vs Stops
    ax2 = axes[0, 1]
    scatter2 = ax2.scatter(df['w_stops'], df['num_stops'], 
                          c=df['fitness'], cmap='coolwarm', s=100, alpha=0.6, edgecolors='black')
    ax2.set_xlabel('Stops Weight (w2)', fontweight='bold')
    ax2.set_ylabel('Number of Stops', fontweight='bold')
    ax2.set_title('Influence of w2 on Number of Stops (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter2, ax=ax2, label='Fitness')
    
    # Weight Cost vs Cost
    ax3 = axes[1, 0]
    scatter3 = ax3.scatter(df['w_cost'], df['cost'], 
                          c=df['fitness'], cmap='coolwarm', s=100, alpha=0.6, edgecolors='black')
    ax3.set_xlabel('Cost Weight (w3)', fontweight='bold')
    ax3.set_ylabel('Cost Achieved', fontweight='bold')
    ax3.set_title('Influence of w3 on Cost (Mono-objective)', fontweight='bold')
    plt.colorbar(scatter3, ax=ax3, label='Fitness')
    
    # Combined weight distribution
    ax4 = axes[1, 1]
    ax4.scatter(df['w_coverage'], df['w_stops'], 
               s=df['fitness']*200, c=df['fitness'], cmap='viridis', alpha=0.6, edgecolors='black')
    ax4.set_xlabel('Coverage Weight (w1)', fontweight='bold')
    ax4.set_ylabel('Stops Weight (w2)', fontweight='bold')
    ax4.set_title('Weight Distribution (size = fitness) (Mono-objective)', fontweight='bold')
    
    plt.tight_layout()
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"Weight influence plot saved to: {output_file}")
    plt.close()

def plot_fitness_heatmap(df, output_file='fitness_heatmap.png'):
    """Genera heatmap del fitness en función de las combinaciones de pesos"""
    fig, axes = plt.subplots(1, 2, figsize=(16, 6))
    
    # Heatmap w1 vs w2
    pivot1 = df.pivot_table(values='fitness', index='w_stops', columns='w_coverage', aggfunc='mean')
    sns.heatmap(pivot1, annot=False, fmt='.3f', cmap='YlOrRd', ax=axes[0], cbar_kws={'label': 'Fitness'})
    axes[0].set_title('Fitness: Coverage Weight vs Stops Weight (Mono-objective)', fontweight='bold')
    axes[0].set_xlabel('Coverage Weight (w1)', fontweight='bold')
    axes[0].set_ylabel('Stops Weight (w2)', fontweight='bold')
    
    # Heatmap w1 vs w3
    pivot2 = df.pivot_table(values='fitness', index='w_cost', columns='w_coverage', aggfunc='mean')
    sns.heatmap(pivot2, annot=False, fmt='.3f', cmap='YlOrRd', ax=axes[1], cbar_kws={'label': 'Fitness'})
    axes[1].set_title('Fitness: Coverage Weight vs Cost Weight (Mono-objective)', fontweight='bold')
    axes[1].set_xlabel('Coverage Weight (w1)', fontweight='bold')
    axes[1].set_ylabel('Cost Weight (w3)', fontweight='bold')
    
    plt.tight_layout()
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"Fitness heatmap saved to: {output_file}")
    plt.close()


def _normalize_objectives_for_compromise(df: pd.DataFrame) -> pd.DataFrame:
    """Normaliza objetivos a [0,1] para comparabilidad.

    Convención:
    - coverage: maximizar
    - num_stops: minimizar
    - cost: minimizar
    Devuelve columnas normalizadas donde *mayor es mejor*.
    """
    required = ['coverage', 'num_stops', 'cost']
    missing = [c for c in required if c not in df.columns]
    if missing:
        raise ValueError(f"Faltan columnas para compromiso: {missing}")

    norm = pd.DataFrame(index=df.index)

    def minmax(series: pd.Series) -> pd.Series:
        smin = float(series.min())
        smax = float(series.max())
        if np.isclose(smax, smin):
            return pd.Series(np.ones(len(series)), index=series.index, dtype=float)
        return (series.astype(float) - smin) / (smax - smin)

    # coverage (max): normal tal cual
    norm['coverage_norm'] = minmax(df['coverage'])
    # num_stops y cost (min): invertimos para que 1 sea mejor
    norm['stops_norm'] = 1.0 - minmax(df['num_stops'])
    norm['cost_norm'] = 1.0 - minmax(df['cost'])
    return norm


def compute_compromise_solutions(
    df: pd.DataFrame,
    top_k: int = 5,
) -> Tuple[pd.DataFrame, Dict[str, int]]:
    """Calcula un ranking de soluciones de compromiso.

    Usa un criterio tipo TOPSIS:
    - Punto ideal: (1,1,1)
    - Anti-ideal: (0,0,0)
    - Score de cercanía: d_anti / (d_ideal + d_anti)
    Retorna el DataFrame con columnas auxiliares y los índices destacados.
    """
    if len(df) == 0:
        raise ValueError("No hay soluciones para analizar compromiso")

    norm = _normalize_objectives_for_compromise(df)
    ideal = np.array([1.0, 1.0, 1.0])
    anti = np.array([0.0, 0.0, 0.0])
    mat = norm[['coverage_norm', 'stops_norm', 'cost_norm']].to_numpy(dtype=float)

    d_ideal = np.linalg.norm(mat - ideal, axis=1)
    d_anti = np.linalg.norm(mat - anti, axis=1)
    denom = (d_ideal + d_anti)
    # Evitar división por cero (caso extremo)
    closeness = np.where(np.isclose(denom, 0.0), 0.0, d_anti / denom)

    out = df.copy()
    out['coverage_norm'] = norm['coverage_norm']
    out['stops_norm'] = norm['stops_norm']
    out['cost_norm'] = norm['cost_norm']
    out['compromise_score'] = closeness
    out['compromise_rank'] = out['compromise_score'].rank(ascending=False, method='first').astype(int)

    out_sorted = out.sort_values('compromise_score', ascending=False)
    top_k = int(max(1, min(top_k, len(out_sorted))))
    top = out_sorted.head(top_k)

    best_idx = int(top.index[0])
    highlighted = {
        'best_compromise': best_idx,
    }
    return out_sorted, highlighted


def plot_compromise_overlays(
    df: pd.DataFrame,
    ranked_df: pd.DataFrame,
    highlighted: Dict[str, int],
    output_prefix: str,
    *,
    color_column: str = 'fitness',
    color_label: str = 'Fitness',
    cmap: str = 'viridis',
):
    """Plot compromise solutions.

    Works for both mono-objective (with `fitness`) and multi-objective runs.
    For multi-objective, you typically want `color_column='compromise_score'`.
    """
    best_idx = highlighted.get('best_compromise', None)
    if best_idx is None or best_idx not in ranked_df.index:
        raise ValueError("No se pudo determinar la mejor solución de compromiso")

    best = ranked_df.loc[best_idx]
    top5 = ranked_df.head(5).copy()

    # 1) Overlay 3D
    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')
    base = ranked_df
    if color_column in base.columns:
        colors = base[color_column]
        scatter = ax.scatter(
            base['coverage'], base['num_stops'], base['cost'],
            c=colors, cmap=cmap, s=80, alpha=0.35, edgecolors='none'
        )
    else:
        scatter = ax.scatter(
            base['coverage'], base['num_stops'], base['cost'],
            c='#1f77b4', s=80, alpha=0.25, edgecolors='none'
        )
    ax.scatter(
        top5['coverage'], top5['num_stops'], top5['cost'],
        c='crimson', s=180, alpha=0.9, edgecolors='black', marker='^',
        label='Top compromise solutions (TOPSIS)'
    )
    ax.scatter(
        [best['coverage']], [best['num_stops']], [best['cost']],
        c='gold', s=260, alpha=1.0, edgecolors='black', marker='*',
        label='Best compromise solution'
    )
    ax.set_xlabel('Coverage', fontsize=12, fontweight='bold')
    ax.set_ylabel('Number of Stops', fontsize=12, fontweight='bold')
    ax.set_zlabel('Cost', fontsize=12, fontweight='bold')
    ax.set_title('Pareto Front + Compromise Solutions', fontsize=14, fontweight='bold')
    if color_column in base.columns:
        cbar = plt.colorbar(scatter, ax=ax, pad=0.1, shrink=0.8)
        cbar.set_label(color_label, rotation=270, labelpad=20, fontweight='bold')
    ax.legend(loc='best')
    plt.tight_layout()
    out3d = f"{output_prefix}_overlay_3d.png"
    plt.savefig(out3d, dpi=300, bbox_inches='tight')
    print(f"Compromise overlay 3D saved to: {out3d}")
    plt.close()

    # 2) Overlay 2D (3 panels)
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    pairs = [
        ('coverage', 'num_stops', 'Coverage vs Stops'),
        ('coverage', 'cost', 'Coverage vs Cost'),
        ('num_stops', 'cost', 'Stops vs Cost'),
    ]
    axis_labels = {
        'coverage': 'Coverage',
        'num_stops': 'Number of Stops',
        'cost': 'Cost',
    }

    for ax, (x, y, title) in zip(axes, pairs):
        if color_column in base.columns:
            base_scatter = ax.scatter(base[x], base[y], c=base[color_column], cmap=cmap, s=60, alpha=0.35, edgecolors='none')
        else:
            base_scatter = ax.scatter(base[x], base[y], c='#1f77b4', s=60, alpha=0.25, edgecolors='none')
        ax.scatter(top5[x], top5[y], c='crimson', s=140, alpha=0.9, edgecolors='black', marker='^')
        ax.scatter([best[x]], [best[y]], c='gold', s=220, alpha=1.0, edgecolors='black', marker='*')
        ax.set_xlabel(axis_labels.get(x, x), fontweight='bold')
        ax.set_ylabel(axis_labels.get(y, y), fontweight='bold')
        ax.set_title(title, fontweight='bold')
    if color_column in base.columns:
        fig.colorbar(base_scatter, ax=axes, label=color_label, shrink=0.9)
    plt.tight_layout()
    out2d = f"{output_prefix}_overlay_2d.png"
    plt.savefig(out2d, dpi=300, bbox_inches='tight')
    print(f"Compromise overlay 2D saved to: {out2d}")
    plt.close()

    # 3) Parallel coordinates (normalized)
    pc = ranked_df.head(10).copy()
    pc = pc.reset_index(drop=False).rename(columns={'index': 'solution_id'})
    pc['solution_id'] = pc['solution_id'].astype(int)
    pc['is_best'] = pc['solution_id'] == int(best_idx)

    fig, ax = plt.subplots(figsize=(14, 7))
    cols = ['coverage_norm', 'stops_norm', 'cost_norm']
    x = np.arange(len(cols))

    for _, row in pc.iterrows():
        y = row[cols].to_numpy(dtype=float)
        if row['is_best']:
            ax.plot(x, y, color='gold', linewidth=3.0, alpha=1.0)
        else:
            ax.plot(x, y, color='crimson', linewidth=1.6, alpha=0.45)

    ax.set_xticks(x)
    ax.set_xticklabels(['Coverage', 'Stops (inv)', 'Cost (inv)'], fontweight='bold')
    ax.set_ylim(-0.05, 1.05)
    ax.set_ylabel('Normalized (1 = better)', fontweight='bold')
    ax.set_title('Compromise Solutions (Top 10) - Parallel Coordinates', fontweight='bold')
    outpc = f"{output_prefix}_parallel.png"
    plt.tight_layout()
    plt.savefig(outpc, dpi=300, bbox_inches='tight')
    print(f"Compromise parallel coordinates saved to: {outpc}")
    plt.close()

    # 4) Radar (best compromise)
    labels = ['Coverage', 'Stops (inv)', 'Cost (inv)']
    values = best[cols].to_numpy(dtype=float)
    angles = np.linspace(0, 2 * np.pi, len(labels), endpoint=False)
    values = np.concatenate([values, [values[0]]])
    angles = np.concatenate([angles, [angles[0]]])

    fig = plt.figure(figsize=(8, 8))
    ax = plt.subplot(111, polar=True)
    ax.plot(angles, values, color='gold', linewidth=3)
    ax.fill(angles, values, color='gold', alpha=0.25)
    ax.set_thetagrids(angles[:-1] * 180 / np.pi, labels, fontweight='bold')
    ax.set_ylim(0, 1)
    ax.set_title('Best Compromise Solution (Radar, normalized)', fontweight='bold', pad=20)
    outr = f"{output_prefix}_radar.png"
    plt.tight_layout()
    plt.savefig(outr, dpi=300, bbox_inches='tight')
    print(f"Compromise radar saved to: {outr}")
    plt.close()

def generate_statistics(df, output_file='pareto_statistics.txt'):
    """Genera estadísticas descriptivas del frente de Pareto"""
    with open(output_file, 'w') as f:
        f.write("=" * 70 + "\n")
        f.write("PARETO FRONT STATISTICS\n")
        f.write("=" * 70 + "\n\n")
        
        f.write("OBJECTIVES SUMMARY:\n")
        f.write("-" * 70 + "\n")
        f.write(df[['coverage', 'num_stops', 'cost', 'fitness']].describe().to_string())
        f.write("\n\n")
        
        f.write("BEST SOLUTIONS PER OBJECTIVE:\n")
        f.write("-" * 70 + "\n")
        
        # Mejor coverage
        best_coverage = df.loc[df['coverage'].idxmax()]
        f.write(f"\nBest Coverage:\n")
        f.write(f"  Coverage: {best_coverage['coverage']:.2f}\n")
        f.write(f"  Stops: {best_coverage['num_stops']:.2f}\n")
        f.write(f"  Cost: {best_coverage['cost']:.2f}\n")
        f.write(f"  Weights: w1={best_coverage['w_coverage']:.4f}, w2={best_coverage['w_stops']:.4f}, w3={best_coverage['w_cost']:.4f}\n")
        
        # Mínimo stops
        min_stops = df.loc[df['num_stops'].idxmin()]
        f.write(f"\nMinimum Number of Stops:\n")
        f.write(f"  Coverage: {min_stops['coverage']:.2f}\n")
        f.write(f"  Stops: {min_stops['num_stops']:.2f}\n")
        f.write(f"  Cost: {min_stops['cost']:.2f}\n")
        f.write(f"  Weights: w1={min_stops['w_coverage']:.4f}, w2={min_stops['w_stops']:.4f}, w3={min_stops['w_cost']:.4f}\n")
        
        # Mínimo cost
        min_cost = df.loc[df['cost'].idxmin()]
        f.write(f"\nMinimum Cost:\n")
        f.write(f"  Coverage: {min_cost['coverage']:.2f}\n")
        f.write(f"  Stops: {min_cost['num_stops']:.2f}\n")
        f.write(f"  Cost: {min_cost['cost']:.2f}\n")
        f.write(f"  Weights: w1={min_cost['w_coverage']:.4f}, w2={min_cost['w_stops']:.4f}, w3={min_cost['w_cost']:.4f}\n")
        
        # Mejor fitness
        best_fitness = df.loc[df['fitness'].idxmax()]
        f.write(f"\nBest Global Fitness:\n")
        f.write(f"  Coverage: {best_fitness['coverage']:.2f}\n")
        f.write(f"  Stops: {best_fitness['num_stops']:.2f}\n")
        f.write(f"  Cost: {best_fitness['cost']:.2f}\n")
        f.write(f"  Fitness: {best_fitness['fitness']:.6f}\n")
        f.write(f"  Weights: w1={best_fitness['w_coverage']:.4f}, w2={best_fitness['w_stops']:.4f}, w3={best_fitness['w_cost']:.4f}\n")

        # Compromise solution (TOPSIS)
        try:
            ranked_df, highlighted = compute_compromise_solutions(df, top_k=5)
            best_idx = highlighted['best_compromise']
            best_comp = ranked_df.loc[best_idx]
            f.write("\nCOMPROMISE SOLUTION (TOPSIS):\n")
            f.write("-" * 70 + "\n")
            f.write(f"  compromise_score: {best_comp['compromise_score']:.6f}\n")
            f.write(f"  Coverage: {best_comp['coverage']:.2f}\n")
            f.write(f"  Stops: {best_comp['num_stops']:.2f}\n")
            f.write(f"  Cost: {best_comp['cost']:.2f}\n")
            f.write(
                "  Normalized (1=better): "
                f"coverage={best_comp['coverage_norm']:.3f}, "
                f"stops_inv={best_comp['stops_norm']:.3f}, "
                f"cost_inv={best_comp['cost_norm']:.3f}\n"
            )
            f.write(
                f"  Weights: w1={best_comp['w_coverage']:.4f}, w2={best_comp['w_stops']:.4f}, w3={best_comp['w_cost']:.4f}\n"
            )
        except Exception as e:
            f.write("\nCOMPROMISE SOLUTION (TOPSIS): Not available\n")
            f.write(f"  Reason: {e}\n")
        
        f.write("\n" + "=" * 70 + "\n")
    
    print(f"Statistics saved to: {output_file}")


def generate_statistics_multi(df: pd.DataFrame, output_file: str):
    """Statistics for multi-objective results (no fitness/weights expected)."""
    with open(output_file, 'w') as f:
        f.write("=" * 70 + "\n")
        f.write("MULTI-OBJECTIVE PARETO STATISTICS\n")
        f.write("=" * 70 + "\n\n")

        f.write("OBJECTIVES SUMMARY:\n")
        f.write("-" * 70 + "\n")
        f.write(df[['coverage', 'num_stops', 'cost']].describe().to_string())
        f.write("\n\n")

        f.write("BEST SOLUTIONS PER OBJECTIVE:\n")
        f.write("-" * 70 + "\n")

        best_coverage = df.loc[df['coverage'].idxmax()]
        f.write("\nBest Coverage:\n")
        f.write(f"  Coverage: {best_coverage['coverage']:.2f}\n")
        f.write(f"  Stops: {best_coverage['num_stops']:.2f}\n")
        f.write(f"  Cost: {best_coverage['cost']:.6f}\n")

        min_stops = df.loc[df['num_stops'].idxmin()]
        f.write("\nMinimum Number of Stops:\n")
        f.write(f"  Coverage: {min_stops['coverage']:.2f}\n")
        f.write(f"  Stops: {min_stops['num_stops']:.2f}\n")
        f.write(f"  Cost: {min_stops['cost']:.6f}\n")

        min_cost = df.loc[df['cost'].idxmin()]
        f.write("\nMinimum Cost:\n")
        f.write(f"  Coverage: {min_cost['coverage']:.2f}\n")
        f.write(f"  Stops: {min_cost['num_stops']:.2f}\n")
        f.write(f"  Cost: {min_cost['cost']:.6f}\n")

        try:
            ranked_df, highlighted = compute_compromise_solutions(df, top_k=5)
            best_idx = highlighted['best_compromise']
            best_comp = ranked_df.loc[best_idx]
            f.write("\nCOMPROMISE SOLUTION (TOPSIS):\n")
            f.write("-" * 70 + "\n")
            f.write(f"  compromise_score: {best_comp['compromise_score']:.6f}\n")
            f.write(f"  Coverage: {best_comp['coverage']:.2f}\n")
            f.write(f"  Stops: {best_comp['num_stops']:.2f}\n")
            f.write(f"  Cost: {best_comp['cost']:.6f}\n")
            f.write(
                "  Normalized (1=better): "
                f"coverage={best_comp['coverage_norm']:.3f}, "
                f"stops_inv={best_comp['stops_norm']:.3f}, "
                f"cost_inv={best_comp['cost_norm']:.3f}\n"
            )
        except Exception as e:
            f.write("\nCOMPROMISE SOLUTION (TOPSIS): Not available\n")
            f.write(f"  Reason: {e}\n")

        f.write("\n" + "=" * 70 + "\n")

    print(f"Multi-objective statistics saved to: {output_file}")


def plot_pareto_comparison_3d(mono_df: pd.DataFrame, multi_df: pd.DataFrame, output_file: str):
    """3D comparison: mono-objective vs multi-objective Pareto approximations."""
    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')

    ax.scatter(
        mono_df['coverage'], mono_df['num_stops'], mono_df['cost'],
        c='#1f77b4', s=70, alpha=0.55, edgecolors='black', linewidths=0.4,
        label='Mono-objective (weighted aggregation)'
    )
    ax.scatter(
        multi_df['coverage'], multi_df['num_stops'], multi_df['cost'],
        c='#ff7f0e', s=90, alpha=0.70, edgecolors='black', linewidths=0.4, marker='^',
        label='Multi-objective (3 objectives)'
    )

    ax.set_xlabel('Coverage', fontsize=12, fontweight='bold')
    ax.set_ylabel('Number of Stops', fontsize=12, fontweight='bold')
    ax.set_zlabel('Cost', fontsize=12, fontweight='bold')
    ax.set_title('Pareto Approximation Comparison (3D)', fontsize=14, fontweight='bold')
    ax.legend(loc='best')
    plt.tight_layout()
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"Pareto comparison 3D saved to: {output_file}")
    plt.close()


def plot_pareto_comparison_2d(mono_df: pd.DataFrame, multi_df: pd.DataFrame, output_file: str):
    """2D projections comparison: mono-objective vs multi-objective."""
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    axis_labels = {
        'coverage': 'Coverage',
        'num_stops': 'Number of Stops',
        'cost': 'Cost',
    }
    pairs = [
        ('coverage', 'num_stops', 'Coverage vs Stops'),
        ('coverage', 'cost', 'Coverage vs Cost'),
        ('num_stops', 'cost', 'Stops vs Cost'),
    ]

    for ax, (x, y, title) in zip(axes, pairs):
        ax.scatter(
            mono_df[x], mono_df[y],
            c='#1f77b4', s=55, alpha=0.55, edgecolors='black', linewidths=0.3,
            label='Mono-objective'
        )
        ax.scatter(
            multi_df[x], multi_df[y],
            c='#ff7f0e', s=75, alpha=0.70, edgecolors='black', linewidths=0.3, marker='^',
            label='Multi-objective'
        )
        ax.set_xlabel(axis_labels.get(x, x), fontweight='bold')
        ax.set_ylabel(axis_labels.get(y, y), fontweight='bold')
        ax.set_title(title, fontweight='bold')
        ax.grid(True, alpha=0.25)

    # Single legend
    handles, labels = axes[0].get_legend_handles_labels()
    fig.legend(handles, labels, loc='upper center', ncol=2, frameon=True)

    plt.tight_layout(rect=[0, 0, 1, 0.92])
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"Pareto comparison 2D saved to: {output_file}")
    plt.close()

def main():
    """Función principal"""
    print("=" * 70)
    print("PARETO FRONT VISUALIZATION")
    print("=" * 70)
    print()
    
    try:
        # Load mono-objective results (existing weighted run)
        mono_df, mono_source = load_latest_mono_results()
        print(f"Mono-objective solutions: {len(mono_df)}")

        # Load multi-objective results (new 3-objective run)
        try:
            multi_df, multi_source = load_latest_multi_results()
            print(f"Multi-objective solutions: {len(multi_df)}")
        except FileNotFoundError:
            multi_df, multi_source = None, None
            print("Multi-objective CSV not found yet (pareto_results_multi_*.csv).")

        print()
        
        # Create output directory
        output_dir = "pareto_analysis"
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # Mono-objective visualizations
        print("Generating mono-objective visualizations...")
        plot_pareto_3d(mono_df, f'{output_dir}/mono_pareto_3d.png')
        plot_pareto_2d_projections(mono_df, f'{output_dir}/mono_pareto_2d_projections.png')
        plot_weight_influence(mono_df, f'{output_dir}/mono_weight_influence.png')
        plot_fitness_heatmap(mono_df, f'{output_dir}/mono_fitness_heatmap.png')

        # Comparison plots
        if multi_df is not None:
            print("\nGenerating mono vs multi comparison plots...")
            plot_pareto_comparison_3d(mono_df, multi_df, f'{output_dir}/pareto_comparison_3d.png')
            plot_pareto_comparison_2d(mono_df, multi_df, f'{output_dir}/pareto_comparison_2d.png')

        # Compromise solution analysis (mono-objective)
        print("\nGenerating compromise-solution plots (mono-objective)...")
        ranked_df, highlighted = compute_compromise_solutions(mono_df, top_k=10)
        compromise_csv = os.path.join(output_dir, 'mono_compromise_solutions.csv')
        ranked_df.reset_index(drop=False).rename(columns={'index': 'solution_id'}).to_csv(compromise_csv, index=False)
        print(f"Compromise ranking saved to: {compromise_csv}")
        plot_compromise_overlays(
            df=mono_df,
            ranked_df=ranked_df,
            highlighted=highlighted,
            output_prefix=os.path.join(output_dir, 'mono_compromise'),
            color_column='fitness',
            color_label='Fitness',
            cmap='viridis'
        )

        # Compromise solution analysis (multi-objective)
        if multi_df is not None:
            print("\nGenerating compromise-solution plots (multi-objective)...")
            ranked_multi, highlighted_multi = compute_compromise_solutions(multi_df, top_k=10)
            compromise_multi_csv = os.path.join(output_dir, 'multi_compromise_solutions.csv')
            ranked_multi.reset_index(drop=False).rename(columns={'index': 'solution_id'}).to_csv(compromise_multi_csv, index=False)
            print(f"Compromise ranking saved to: {compromise_multi_csv}")
            plot_compromise_overlays(
                df=multi_df,
                ranked_df=ranked_multi,
                highlighted=highlighted_multi,
                output_prefix=os.path.join(output_dir, 'multi_compromise'),
                color_column='compromise_score',
                color_label='Compromise Score',
                cmap='plasma'
            )
        
        # Statistics
        print("\nGenerating statistics...")
        generate_statistics(mono_df, f'{output_dir}/mono_pareto_statistics.txt')
        if multi_df is not None:
            generate_statistics_multi(multi_df, f'{output_dir}/multi_pareto_statistics.txt')
        
        print("\n" + "=" * 70)
        print("DONE")
        print(f"All files saved under: {output_dir}/")
        print("=" * 70)
        
    except FileNotFoundError as e:
        print(f"Error: {e}")
        print("Run the Java solver first to generate CSV outputs.")
    except Exception as e:
        print(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
